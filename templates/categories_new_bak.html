{% extends "base.html" %}

{% block title %}资源 - SHT{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="/static/css/categories.css">
{% endblock %}

{% block content %}
<h1 class="page-title">资源</h1>

<!-- 筛选区域 -->
<div class="filters-section">
    <div class="filters-grid">
        <div class="filter-group">
            <label for="filterCategory">所属板块</label>
            <select id="filterCategory">
                <option value="">加载中...</option>
            </select>
        </div>
        <div class="filter-group">
            <label for="perPage">每页</label>
            <select id="perPage">
                <option value="20">20</option>
                <option value="40">40</option>
                <option value="80">80</option>
            </select>
        </div>
        <div class="filter-group">
            <label for="filterStart">开始日期</label>
            <input type="date" id="filterStart">
        </div>
        <div class="filter-group">
            <label for="filterEnd">结束日期</label>
            <input type="date" id="filterEnd">
        </div>
        <div class="filter-group">
            <label for="filterKeyword">关键词</label>
            <div style="display: flex; gap: 0.5rem; align-items: flex-end;">
                <input type="text" id="filterKeyword" placeholder="搜索关键词..."
                    style="flex: 1; height: 2.75rem; padding: 0 0.75rem; border: 1px solid var(--border); border-radius: 8px; background: var(--background); color: var(--foreground); font-size: 0.875rem;">
                <button id="filterBtn" class="btn btn-purple">筛选</button>
                <button id="clearBtn" class="btn btn-primary">还原</button>
            </div>
        </div>
    </div>
</div>

<!-- 筛选状态指示器 -->
<div id="filterStatus" class="filter-status">
    <span>当前筛选条件已保存，切换页面后会自动恢复</span>
</div>

<!-- 资源列表 -->
<div id="resourceList">
    <div class="loading">正在加载资源...</div>
</div>

<!-- 分页 -->
<div id="pagination" class="pagination"></div>

<!-- 大图查看器 -->
<div id="lightbox" class="lightbox">
    <img id="lightboxImage" class="lightbox-image" src="" alt="大图预览">
</div>
{% endblock %}
{% block extra_js %}
<script>
    // 资源页面特定的JavaScript
    let currentPage = 1;
    let isLoading = false;

    // 筛选状态管理
    const FILTER_STORAGE_KEY = 'sht_resource_filters';

    document.addEventListener('DOMContentLoaded', function () {
        bindEvents();

        // 并行加载数据
        Promise.all([
            loadCategories()
        ]).then(() => {
            // 恢复筛选状态
            const savedState = restoreFilterState();
            if (savedState) {
                applyFilterStateToUI(savedState);
                // 静默恢复筛选条件，不显示通知
            }

            // 加载资源
            loadResources(savedState ? savedState.page : 1);
        });
    });

    // 保存筛选状态
    function saveFilterState() {
        try {
            const filterState = {
                category: document.getElementById('filterCategory').value,
                perPage: document.getElementById('perPage').value,
                startDate: document.getElementById('filterStart').value,
                endDate: document.getElementById('filterEnd').value,
                keyword: document.getElementById('filterKeyword').value.trim(),
                page: currentPage,
                timestamp: Date.now()
            };

            localStorage.setItem(FILTER_STORAGE_KEY, JSON.stringify(filterState));
            updateFilterStatusIndicator(filterState);
        } catch (e) {
            console.error('保存筛选状态失败', e);
        }
    }

    // 更新筛选状态指示器
    function updateFilterStatusIndicator(filterState) {
        const indicator = document.getElementById('filterStatus');
        if (!indicator) return;

        const hasActiveFilters = filterState.category ||
            filterState.startDate ||
            filterState.endDate ||
            filterState.keyword ||
            filterState.perPage !== '20';

        if (hasActiveFilters) {
            indicator.style.display = 'block';

            const conditions = [];
            if (filterState.category) conditions.push(`板块: ${filterState.category}`);
            if (filterState.keyword) conditions.push(`关键词: ${filterState.keyword}`);
            if (filterState.startDate) conditions.push(`开始: ${filterState.startDate}`);
            if (filterState.endDate) conditions.push(`结束: ${filterState.endDate}`);
            if (filterState.perPage !== '20') conditions.push(`每页: ${filterState.perPage}`);

            const conditionText = conditions.length > 0 ? ` (${conditions.join(', ')})` : '';
            indicator.innerHTML = `<span>筛选条件已保存${conditionText}</span>`;
        } else {
            indicator.style.display = 'none';
        }
    }
    // 恢复筛选状态
    function restoreFilterState() {
        try {
            const saved = localStorage.getItem(FILTER_STORAGE_KEY);
            if (!saved) return null;

            const filterState = JSON.parse(saved);

            // 检查状态是否过期（24小时）
            const maxAge = 24 * 60 * 60 * 1000;
            if (Date.now() - filterState.timestamp > maxAge) {
                localStorage.removeItem(FILTER_STORAGE_KEY);
                return null;
            }

            return filterState;
        } catch (e) {
            return null;
        }
    }

    // 应用筛选状态到UI
    function applyFilterStateToUI(filterState) {
        if (!filterState) return;

        try {
            if (filterState.category) {
                document.getElementById('filterCategory').value = filterState.category;
            }
            if (filterState.perPage) {
                document.getElementById('perPage').value = filterState.perPage;
            }
            if (filterState.startDate) {
                document.getElementById('filterStart').value = filterState.startDate;
            }
            if (filterState.endDate) {
                document.getElementById('filterEnd').value = filterState.endDate;
            }
            if (filterState.keyword) {
                document.getElementById('filterKeyword').value = filterState.keyword;
            }

            currentPage = filterState.page || 1;
        } catch (e) {
            console.error('应用筛选状态失败', e);
        }
    }

    // 清除筛选状态
    function clearFilterState() {
        try {
            localStorage.removeItem(FILTER_STORAGE_KEY);
        } catch (e) {
            console.error('清除筛选状态失败', e);
        }
    }

    // API调用函数 - 修复响应格式处理
    async function fetchAPI(url) {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        const result = await response.json();
        // 处理两种响应格式：1) 包装格式 {success: true, data: {...}} 2) 直接数据
        return result.data !== undefined ? result.data : result;
    }
    // 加载板块
    async function loadCategories() {
        try {
            const categories = await fetchAPI('/api/categories');
            const select = document.getElementById('filterCategory');

            select.innerHTML = '<option value="">所有板块</option>';

            categories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat.name;
                option.textContent = `${cat.name} (${cat.count})`;
                select.appendChild(option);
            });
        } catch (error) {
            console.error('板块加载失败', error);
            const select = document.getElementById('filterCategory');
            select.innerHTML = '<option value="">加载失败</option>';
        }
    }

    // 加载资源
    async function loadResources(page = 1) {
        if (isLoading) return;

        isLoading = true;
        currentPage = page;

        try {
            showLoading();

            // 获取筛选参数
            const category = document.getElementById('filterCategory').value;
            const perPage = document.getElementById('perPage').value;
            const startDate = document.getElementById('filterStart').value;
            const endDate = document.getElementById('filterEnd').value;
            const keyword = document.getElementById('filterKeyword').value.trim();

            // 构建URL
            let url = `/api/resources?page=${page}&per_page=${perPage}`;
            if (category) url += `&category=${encodeURIComponent(category)}`;
            if (keyword) url += `&search=${encodeURIComponent(keyword)}`;
            if (startDate) url += `&date_start=${encodeURIComponent(startDate)}`;
            if (endDate) url += `&date_end=${encodeURIComponent(endDate)}`;

            const data = await fetchAPI(url);

            // 渲染资源列表
            renderResources(data.resources || []);

            // 渲染分页
            renderPagination(data.pages || 1, page, data.total || 0);

            // 保存当前筛选状态
            saveFilterState();

        } catch (error) {
            showError(error.message);
        } finally {
            isLoading = false;
        }
    }
    // 渲染资源列表
    function renderResources(resources) {
        const container = document.getElementById('resourceList');

        if (!resources || resources.length === 0) {
            container.innerHTML = '<div class="loading">没有找到符合条件的资源</div>';
            return;
        }

        const grid = document.createElement('div');
        grid.className = 'resources-grid';

        resources.forEach(resource => {
            const card = document.createElement('div');
            card.className = 'resource-card';

            const imgSrc = (resource.preview_images && resource.preview_images.length > 0)
                ? resource.preview_images[0] : '';

            card.innerHTML = `
            <div class="resource-thumb-container" onclick="openLightbox('${imgSrc}')">
                ${imgSrc ?
                    `<img class="resource-thumb" src="${imgSrc}" alt="预览图" onerror="this.style.display='none'">` :
                    `<div class="resource-thumb"></div>`
                }
                <div class="resource-thumb-mask">
                    <canvas class="spoiler-canvas"></canvas>
                </div>
            </div>
            <div class="resource-body">
                <div class="resource-title">${resource.title || '无标题'}</div>
                <div class="resource-meta">
                    <span class="resource-badge type">${resource.sub_type || '未知'}</span>
                    <span class="resource-badge date">${resource.publish_date || '未知'}</span>
                    <span class="resource-badge size">${resource.size ? (resource.size + 'MB') : '未知'}</span>
                </div>
                <div class="resource-actions">
                    <a class="btn btn-purple" href="https://sehuatang.org/forum.php?mod=viewthread&tid=${resource.tid}" target="_blank">查看详情</a>
                    ${resource.magnet ?
                    `<button class="btn btn-success" onclick="copyMagnet(this)" data-magnet="${resource.magnet.replace(/"/g, '&quot;').replace(/'/g, '&#39;')}">复制磁力</button>` :
                    `<button class="btn btn-ghost" disabled>无磁力链接</button>`
                }
                </div>
            </div>
        `;

            grid.appendChild(card);
        });

        container.innerHTML = '';
        container.appendChild(grid);
        initSpoilerCanvases();
    }

    // 渲染分页
    function renderPagination(totalPages, currentPage, totalCount) {
        const container = document.getElementById('pagination');
        container.innerHTML = '';

        if (totalPages <= 1) return;

        // 首页
        if (currentPage > 1) {
            const firstBtn = document.createElement('button');
            firstBtn.className = 'btn btn-pagination';
            firstBtn.textContent = '首';
            firstBtn.title = '首页';
            firstBtn.onclick = () => loadResources(1);
            container.appendChild(firstBtn);
        }

        // 上一页
        if (currentPage > 1) {
            const prevBtn = document.createElement('button');
            prevBtn.className = 'btn btn-pagination btn-pink';
            prevBtn.textContent = '◀';
            prevBtn.title = '上一页';
            prevBtn.onclick = () => loadResources(currentPage - 1);
            container.appendChild(prevBtn);
        }

        // 页码逻辑：桌面端显示前后各2页，移动端显示前后各1页
        let startPage, endPage;
        const isMobile = window.innerWidth <= 768;
        const pageRange = isMobile ? 1 : 2;

        if (totalPages <= 2 * pageRange + 1) {
            // 总页数小于等于范围，显示所有页码
            startPage = 1;
            endPage = totalPages;
        } else {
            // 显示当前页前后各pageRange页
            startPage = Math.max(1, currentPage - pageRange);
            endPage = Math.min(totalPages, currentPage + pageRange);
            
            // 如果靠近开头，向后扩展
            if (startPage === 1) {
                endPage = Math.min(totalPages, 1 + 2 * pageRange);
            }
            // 如果靠近结尾，向前扩展
            if (endPage === totalPages) {
                startPage = Math.max(1, totalPages - 2 * pageRange);
            }
        }

        // 如果起始页不是1，显示省略号
        if (startPage > 1) {
            const ellipsis = document.createElement('span');
            ellipsis.className = 'pagination-ellipsis';
            ellipsis.textContent = '...';
            container.appendChild(ellipsis);
        }

        // 页码按钮
        for (let i = startPage; i <= endPage; i++) {
            const pageBtn = document.createElement('button');
            pageBtn.className = i === currentPage ? 'btn btn-pagination btn-primary' : 'btn btn-pagination';
            pageBtn.textContent = i;
            pageBtn.onclick = () => loadResources(i);
            container.appendChild(pageBtn);
        }

        // 如果结束页不是最后一页，显示省略号
        if (endPage < totalPages) {
            const ellipsis = document.createElement('span');
            ellipsis.className = 'pagination-ellipsis';
            ellipsis.textContent = '...';
            container.appendChild(ellipsis);
        }
        // 下一页
        if (currentPage < totalPages) {
            const nextBtn = document.createElement('button');
            nextBtn.className = 'btn btn-pagination btn-pink';
            nextBtn.textContent = '▶';
            nextBtn.title = '下一页';
            nextBtn.onclick = () => loadResources(currentPage + 1);
            container.appendChild(nextBtn);
        }

        // 尾页
        if (currentPage < totalPages) {
            const lastBtn = document.createElement('button');
            lastBtn.className = 'btn btn-pagination';
            lastBtn.textContent = '尾';
            lastBtn.title = '尾页';
            lastBtn.onclick = () => loadResources(totalPages);
            container.appendChild(lastBtn);
        }

        // 显示统计信息
        const info = document.createElement('span');
        info.className = 'pagination-info';
        info.textContent = `第${currentPage}页，共${totalPages}页，总计${totalCount}条记录`;
        container.appendChild(info);
    }

    // 复制磁力链接 - 移动端优化版本
    function copyMagnet(button) {
        let magnetLink;

        // 如果传入的是按钮元素，从data-magnet属性获取
        if (button && button.getAttribute) {
            magnetLink = button.getAttribute('data-magnet');
        } else {
            // 如果传入的是字符串，直接使用
            magnetLink = button;
        }

        if (!magnetLink) {
            showToast('没有找到磁力链接', 'warning');
            return;
        }

        // 检测是否为移动设备
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // 移动端优化：防止页面缩放
        if (isMobile) {
            // 阻止默认行为和事件冒泡
            if (button && button.blur) {
                button.blur();
            }

            // 延迟执行复制，避免与其他事件冲突
            setTimeout(() => {
                performCopy(magnetLink);
            }, 100);
        } else {
            performCopy(magnetLink);
        }

        function performCopy(text) {
            // 优先使用现代 Clipboard API，但提供完整的降级方案
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => {
                    showToast('磁力链接已复制到剪贴板', 'success');
                }).catch((error) => {
                    console.warn('Clipboard API 失败，使用降级方案:', error);
                    fallbackCopy(text);
                });
            } else {
                // 降级方案：使用传统的 execCommand
                fallbackCopy(text);
            }
        }

        function fallbackCopy(text) {
            try {
                const textarea = document.createElement('textarea');
                textarea.value = text;
                textarea.style.position = 'fixed';
                textarea.style.left = '-999999px';
                textarea.style.top = '-999999px';
                textarea.style.opacity = '0';
                textarea.style.pointerEvents = 'none';
                textarea.setAttribute('readonly', '');
                textarea.setAttribute('contenteditable', 'true');

                document.body.appendChild(textarea);

                // 移动端特殊处理
                if (isMobile) {
                    textarea.setSelectionRange(0, 99999);
                    textarea.focus();
                    textarea.select();
                } else {
                    textarea.focus();
                    textarea.select();
                }

                const successful = document.execCommand('copy');
                document.body.removeChild(textarea);

                if (successful) {
                    showToast('磁力链接已复制到剪贴板', 'success');
                } else {
                    showToast('复制失败，请手动复制磁力链接', 'error');
                    console.error('execCommand copy 失败');
                }
            } catch (error) {
                console.error('降级复制方案失败:', error);
                showToast('复制失败: ' + error.message, 'error');
            }
        }
    }

    // 显示加载状态
    function showLoading() {
        const container = document.getElementById('resourceList');
        container.innerHTML = '<div class="loading">正在加载...</div>';
    }

    // 显示错误信息
    function showError(message) {
        const container = document.getElementById('resourceList');
        container.innerHTML = `
        <div class="error-message">
            <h3>加载失败</h3>
            <p>${message}</p>
            <button class="btn btn-primary" onclick="loadResources(1)">重试</button>
        </div>
    `;
    }
    // 清除所有筛选条件
    function clearFilters() {
        document.getElementById('filterCategory').value = '';
        document.getElementById('perPage').value = '20';
        document.getElementById('filterStart').value = '';
        document.getElementById('filterEnd').value = '';
        document.getElementById('filterKeyword').value = '';

        clearFilterState();

        const indicator = document.getElementById('filterStatus');
        if (indicator) {
            indicator.style.display = 'none';
        }

        loadResources(1);
    }

    // 显示筛选恢复提示（已禁用）
    function showFilterRestoreNotice() {
        // 静默恢复筛选条件，不显示通知
        return;
    }
    // 事件绑定
    function bindEvents() {
        document.getElementById('filterBtn').addEventListener('click', () => loadResources(1));
        document.getElementById('clearBtn').addEventListener('click', clearFilters);

        document.getElementById('filterKeyword').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                loadResources(1);
            }
        });

        document.getElementById('filterCategory').addEventListener('change', () => {
            loadResources(1);
        });

        document.getElementById('perPage').addEventListener('change', () => {
            loadResources(1);
        });

        document.getElementById('filterStart').addEventListener('change', saveFilterState);
        document.getElementById('filterEnd').addEventListener('change', saveFilterState);

        let keywordTimeout;
        document.getElementById('filterKeyword').addEventListener('input', () => {
            clearTimeout(keywordTimeout);
            keywordTimeout = setTimeout(saveFilterState, 500);
        });

        // 监听侧边栏状态变化，调整分页条位置
        const sidebar = document.querySelector('.sidebar');
        if (sidebar) {
            const observer = new MutationObserver(() => {
                updatePaginationPosition();
            });
            observer.observe(sidebar, { attributes: true, attributeFilter: ['data-state'] });
        }

        // 监听窗口大小变化
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(updatePaginationPosition, 100);
        });

        // 初始化分页条位置
        updatePaginationPosition();
    }

    // 更新分页条位置以适应侧边栏状态
    function updatePaginationPosition() {
        const pagination = document.getElementById('pagination');
        if (!pagination) return;

        const sidebar = document.querySelector('.sidebar');
        if (!sidebar) return;

        const isCollapsed = sidebar.getAttribute('data-state') === 'collapsed';
        const windowWidth = window.innerWidth;
        const isDesktop = windowWidth > 1024;

        if (isDesktop) {
            // PC 端 (>1024px) - 侧边栏可见
            if (isCollapsed) {
                // 侧边栏收起时，使用 sidebar-width-icon
                const sidebarWidthIcon = getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width-icon').trim();
                const safeAreaLeft = getComputedStyle(document.documentElement).getPropertyValue('--safe-area-inset-left').trim() || '0px';
                pagination.style.left = `calc(${sidebarWidthIcon} + max(0px, ${safeAreaLeft}) + 1.5rem)`;
            } else {
                // 侧边栏展开时，使用 sidebar-width（CSS 默认值）
                pagination.style.left = '';
            }
        } else {
            // 平板端和移动端 (≤1024px) - 侧边栏隐藏，不需要调整
            pagination.style.left = '';
        }
    }

    // 大图查看器功能
    function openLightbox(imgSrc) {
        if (!imgSrc) return;

        const lightbox = document.getElementById('lightbox');
        const lightboxImage = document.getElementById('lightboxImage');

        lightboxImage.src = imgSrc;
        lightbox.classList.add('active');

        // 点击lightbox关闭
        lightbox.onclick = closeLightbox;
    }

    function closeLightbox() {
        const lightbox = document.getElementById('lightbox');
        lightbox.classList.remove('active');
    }

    // Telegram 风格粒子遮罩（Canvas）
    const spoilerInstances = [];
    let spoilerAnimId = null;
    let spoilerLastTs = 0;

    function hash(x, y) {
        return (Math.sin(x * 127.1 + y * 311.7) * 43758.5453123) % 1;
    }

    function fade(t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
    }

    function lerp(a, b, t) {
        return a + (b - a) * t;
    }

    function noise(x, y) {
        const x0 = Math.floor(x);
        const y0 = Math.floor(y);
        const x1 = x0 + 1;
        const y1 = y0 + 1;
        const sx = fade(x - x0);
        const sy = fade(y - y0);
        const n00 = hash(x0, y0);
        const n10 = hash(x1, y0);
        const n01 = hash(x0, y1);
        const n11 = hash(x1, y1);
        const ix0 = lerp(n00, n10, sx);
        const ix1 = lerp(n01, n11, sx);
        return lerp(ix0, ix1, sy);
    }

    function flowField(x, y, t) {
        const scale = 0.0045;
        const n = noise(x * scale + t * 0.02, y * scale + t * 0.02);
        const angle = n * Math.PI * 2.0;
        return { vx: Math.cos(angle), vy: Math.sin(angle) };
    }

    function createSpoilerInstance(canvas) {
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const inst = { canvas, ctx, dpr, W: 0, H: 0, particles: [] };
        return inst;
    }

    function resizeSpoilerInstance(inst) {
        const rect = inst.canvas.getBoundingClientRect();
        inst.W = Math.max(1, rect.width);
        inst.H = Math.max(1, rect.height);
        inst.canvas.width = Math.round(inst.W * inst.dpr);
        inst.canvas.height = Math.round(inst.H * inst.dpr);
        inst.ctx.setTransform(inst.dpr, 0, 0, inst.dpr, 0, 0);
    }
    /* 根据画布面积动态计算环形粒子的数量 */
    function initSpoilerParticles(inst) {
        /* 下限10，上限30，面积0.0006 */
        const ringCount = Math.min(30, Math.max(10, Math.round(inst.W * inst.H * 0.006)));
        inst.particles = Array.from({ length: ringCount }).map(() => {
            const life = 1.6 + Math.random() * 2.4;
            /* 动态计算每个环形粒子的最大半径 */
            /* 最小0.25，最大0.4，最小35px */
            const maxR = Math.max(35, Math.min(inst.W, inst.H) * (0.25 + Math.random() * 0.15));
            return {
                x: Math.random() * inst.W,
                y: Math.random() * inst.H,
                start: -Math.random() * life,
                life,
                maxR,
                thickness: 0.35 + Math.random() * 0.65,
                alpha: 0.12 + Math.random() * 0.28,
            };
        });

        /* 根据面积动态计算背景小粒子的数量 */
        /* 下限2000，上限4000，面积0.222 */
        const bgCount = Math.min(4000, Math.max(2000, Math.round(inst.W * inst.H * 0.066)));
        inst.bgParticles = Array.from({ length: bgCount }).map(() => ({
            x: Math.random() * inst.W,
            y: Math.random() * inst.H,
            r: 0.35 + Math.random() * 0.6,
            o: 0.08 + Math.random() * 0.2,
            life: 1 + Math.random() * 2.5,
            age: Math.random() * 2.5,
            speed: 0.2 + Math.random() * 0.6,
        }));
    }

    function renderSpoilerInstance(inst, t, dt) {
        const ctx = inst.ctx;
        ctx.clearRect(0, 0, inst.W, inst.H);

        for (const p of inst.bgParticles || []) {
            p.age += dt;
            if (p.age > p.life) {
                p.x = Math.random() * inst.W;
                p.y = Math.random() * inst.H;
                p.life = 1 + Math.random() * 2.5;
                p.age = 0;
                /* 背景粒子的大小 */
                p.r = 0.35 + Math.random() * 0.6;
                p.o = 0.22 + Math.random() * 0.4;
                p.speed = 0.2 + Math.random() * 0.6;
            }
            const v = flowField(p.x, p.y, t);
            p.x += v.vx * p.speed * 60 * dt;
            p.y += v.vy * p.speed * 60 * dt;
            if (p.x < 0) p.x += inst.W;
            if (p.x > inst.W) p.x -= inst.W;
            if (p.y < 0) p.y += inst.H;
            if (p.y > inst.H) p.y -= inst.H;
            ctx.globalAlpha = p.o * (1 - p.age / p.life);
            ctx.fillStyle = 'rgba(255,255,255,0.98)';
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
            ctx.fill();
        }

        for (const r of inst.particles) {
            let age = t - r.start;
            if (age < 0) continue;
            if (age > r.life) {
                r.start = t + Math.random() * 0.6;
                r.x = Math.random() * inst.W;
                r.y = Math.random() * inst.H;
                r.life = 1.6 + Math.random() * 2.4;
                /* 动态计算每个环形粒子的最大半径 */
                /* 最小0.25，最大0.4，最小35px */
                r.maxR = Math.max(35, Math.min(inst.W, inst.H) * (0.25 + Math.random() * 0.15));
                r.thickness = 0.35 + Math.random() * 0.65;
                r.alpha = 0.28 + Math.random() * 0.45;
                continue;
            }
            const p = age / r.life;
            const radius = r.maxR * p;
            const fade = 1 - p;
            const dotCount = Math.max(48, Math.floor(radius * 1.2));

            for (let i = 0; i < dotCount; i++) {
                const a = (i / dotCount) * Math.PI * 2;
                const x = r.x + Math.cos(a) * radius;
                const y = r.y + Math.sin(a) * radius;
                /* 环形粒子的大小 */
                const size = 0.35 + Math.random() * 0.6;
                ctx.globalAlpha = r.alpha * fade * (0.6 + Math.random() * 0.4);
                ctx.fillStyle = 'rgba(255,255,255,0.98)';
                ctx.beginPath();
                ctx.arc(x, y, Math.max(0.22, size), 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }

    function initSpoilerCanvases() {
        spoilerInstances.length = 0;
        const canvases = document.querySelectorAll('.resource-thumb-mask .spoiler-canvas');
        canvases.forEach((canvas) => {
            const inst = createSpoilerInstance(canvas);
            resizeSpoilerInstance(inst);
            initSpoilerParticles(inst);
            spoilerInstances.push(inst);
        });
    }

    function startSpoilerAnimation() {
        if (spoilerAnimId) return;
        const tick = (ts) => {
            const t = ts / 1000;
            const dt = Math.min(0.033, (ts - spoilerLastTs) / 1000 || 0.016);
            spoilerLastTs = ts;
            spoilerInstances.forEach((inst) => renderSpoilerInstance(inst, t, dt));
            spoilerAnimId = requestAnimationFrame(tick);
        };
        spoilerAnimId = requestAnimationFrame(tick);
    }

    function stopSpoilerAnimation() {
        if (!spoilerAnimId) return;
        cancelAnimationFrame(spoilerAnimId);
        spoilerAnimId = null;
        spoilerLastTs = 0;
    }

    // 安全模式管理 - 【修复】从服务器配置读取，支持跨标签页实时同步
    async function initSafeMode() {
        try {
            // 从服务器获取配置
            const response = await fetch('/api/config/values');
            if (!response.ok) {
                console.warn('无法获取配置，使用默认安全模式设置');
                return;
            }
            const config = await response.json();

            // 应用安全模式
            applySafeMode(!!config.SAFE_MODE);

        } catch (e) {
            console.error('安全模式初始化失败:', e);
        }
    }

    // 应用安全模式到 DOM
    function applySafeMode(safeMode) {
        if (safeMode) {
            document.body.classList.add('safe-mode');
            initSpoilerCanvases();
            startSpoilerAnimation();
        } else {
            document.body.classList.remove('safe-mode');
            stopSpoilerAnimation();
        }
        console.log('安全模式已应用:', safeMode ? '开启' : '关闭');
    }

    // 【新增】跨标签页通信 - 监听其他标签页的安全模式变更
    function initSafeModeBroadcast() {
        try {
            const channel = new BroadcastChannel('safe_mode_channel');
            channel.onmessage = function(event) {
                if (event.data && event.data.type === 'SAFE_MODE_CHANGED') {
                    console.log('收到安全模式变更通知:', event.data.safeMode ? '开启' : '关闭');
                    applySafeMode(event.data.safeMode);
                }
            };
        } catch (e) {
            console.warn('BroadcastChannel 不支持，跨标签页实时同步不可用:', e);
        }
    }

    // 页面加载时初始化安全模式
    window.addEventListener('resize', () => {
        if (document.body.classList.contains('safe-mode')) {
            initSpoilerCanvases();
        }
    });

    document.addEventListener('DOMContentLoaded', function () {
        initSafeMode();
        initSafeModeBroadcast();
    });

</script>
{% endblock %}